<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://songsong.org</id>
    <title>陈仁松博客</title>
    <updated>2019-05-26T12:33:07.353Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://songsong.org"/>
    <link rel="self" href="https://songsong.org/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://songsong.org/images/avatar.png</logo>
    <icon>https://songsong.org/favicon.ico</icon>
    <rights>All rights reserved 2019, 陈仁松博客</rights>
    <entry>
        <title type="html"><![CDATA[抓取RTMP视频&音频数据]]></title>
        <id>https://songsong.org/post/rtmp-capture</id>
        <link href="https://songsong.org/post/rtmp-capture">
        </link>
        <updated>2019-05-26T10:26:19.000Z</updated>
        <content type="html"><![CDATA[<p>需要的工具：抓包工具（这里我使用的是<code>WireShark</code>）、<code>Rtmpdump</code></p>
<p>一开始我思路是想分析下html查看下是否有直接的下载地址：
<img src="/data/2017/2/rtmp_1.png" alt="">
查询到了meta.xml,在里面发现了stream的path，这时候发现是rtmp的无法直接下载， 于是想到使用WireShark工具抓包,利用meta.xml里面的 cp11276.edgefcs.net/ondemand ，首先ping 获取ip
<img src="/data/2017/2/rtmp_2.png" alt="">
得到96.17.102.28，通过过滤ip得到下面rtmp的信息
<img src="/data/2017/2/rtmp_3.png" alt="">
url:</p>
<pre><code>rtmp://96.17.102.28/ondemand?_fcs_vhost=cp11276.edgefcs.net
</code></pre>
<p>path:</p>
<pre><code>mp3:media.thomson-webcast.net/index=/1/4/2/5/3/3/6/2/0/0/~/m/instances/8qfcz37z/items/5wurmfcb/clips/dvzgs4dr/0/clip?itemview=b8cchdaae5q3bafgzebcqk55w55m2g4sqc2f68z2nckpafpx_105059808&amp;mmc_installation=mmc_production&amp;mmc_installation_type=prod
</code></pre>
<p>在RtmpDump下面执行</p>
<pre><code>rtmpdump -r &quot;rtmp://96.17.102.28/ondemand?_fcs_vhost=cp11276.edgefcs.net&quot; -y &quot;mp3:media.thomson-webcast.net/index=/1/4/2/5/3/3/6/2/0/0/~/m/instances/8qfcz37z/items/5wurmfcb/clips/dvzgs4dr/0/clip?itemview=b8cchdaae5q3bafgzebcqk55w55m2g4sqc2f68z2nckpafpx_105059808&amp;mmc_installation=mmc_production&amp;mmc_installation_type=prod&quot; -o webcast.mp3
</code></pre>
<p><img src="/data/2017/2/rtmp_4.png" alt="">
下载成功得到webcast.mp3
<img src="/data/2017/2/rtmp_5.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://songsong.org/post/about</id>
        <link href="https://songsong.org/post/about">
        </link>
        <updated>2019-05-26T10:17:20.000Z</updated>
        <content type="html"><![CDATA[<p>Github：https://github.com/chenrensong
Weibo：https://weibo.com/songsongorg</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#基础 - Lazy<T>]]></title>
        <id>https://songsong.org/post/c-lazy</id>
        <link href="https://songsong.org/post/c-lazy">
        </link>
        <updated>2015-03-18T10:18:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-lazyt-概述">1. <code>Lazy&lt;T&gt;</code> 概述</h2>
<p>往往有这样的情景，我们需要创建一个大对象，这样的对象往往需要较长的时间和较多的空间，为了避免在每次运行时创建这种家伙，在.NET Framework 4 后提供一种便捷的方式：<code>Lazy&lt;T&gt;</code>（称之为懒对象）。</p>
<h2 id="2-lazyt-的使用">2. <code>Lazy&lt;T&gt;</code> 的使用</h2>
<p>我们就来看下Lazy<T>如何使用。</p>
<pre><code>
[Serializable]
class Large
{
    public Large() { }
    public void Test()
    {
        Console.WriteLine(&quot;Test&quot;);
    }
}

</code></pre>
<p>上面代码定义了一个<code>Large</code>对象</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Lazy&lt;Large&gt; lazyObject = new Lazy&lt;Large&gt;();
        Console.WriteLine(lazyObject.IsValueCreated);
        lazyObject.Value.Test();
        Console.WriteLine(lazyObject.IsValueCreated);
    }
}
</code></pre>
<p>在<code>Main</code>函数中进行执行，运行结果如下：</p>
<pre><code>False
Test
True
</code></pre>
<p>这个例子很简单，也是Lazy<T>最基本，也是最常用的应用方式，<code>Lazy&lt;T&gt;</code>实现了按需延迟加载</p>
<h2 id="3-实现自己的lazyt">3. 实现自己的<code>Lazy&lt;T&gt;</code></h2>
<p>在.NET Framework 4.0之前，来看看我们是怎么样定义Lazy<T>的吧。</p>
<pre><code>class MyLazy&lt;T&gt; where T : new()
{
    private T value;
    private bool isLoaded;
    public MyLazy()
    {
        isLoaded = false;
    }
    public T Value
    {
        get
        {
            if (!isLoaded)
            {
                value = new T();
                isLoaded = true;
            }
            return value;
        }
    }
}
</code></pre>
<p>这应该是最简单版本的Lazy<T>了，没有线程安全检测，只有着访问时创建对象，可是对于我们一般的应用来说也许就已经足够了，大家也可以读下老赵写的 <a href="http://www.cnblogs.com/JeffreyZhao/archive/2009/09/07/standard-lazy-proxy.html">较为理想的延迟代理的编写方式</a></p>
<h2 id="4-lazyt的net-framework实现">4. <code>Lazy&lt;T&gt;</code>的.NET Framework实现</h2>
<p>其实.NET Framework和上面的实现大同小异，有两点主要的不同：</p>
<h3 id="a-引入了boxed内部类">A. 引入了Boxed内部类：</h3>
<pre><code>[Serializable]
private class Boxed
{
    // Fields
    internal T m_value;

    // Methods
    [TargetedPatchingOptOut(&quot;Performance critical to inline this type of method across NGen image boundaries&quot;)]
    internal Boxed(T value)
    {
        this.m_value = value;
    }
}
</code></pre>
<p>该内部类取代了我在上面实现中的泛型约束，使之更通用。</p>
<p>但是也应该要注意，如果T为结构体，那么由于T很大，所以装箱拆箱反而也许是个更耗费效率的事情，因此，对值类型慎用<code>Lazy&lt;T&gt;</code>。</p>
<h3 id="b-线程安全的控制">B. 线程安全的控制</h3>
<p>在线程安全的控制选项中，.NET Framework为我们提供了这样的枚举选项：</p>
<pre><code>public enum LazyThreadSafetyMode
{
    None,
    PublicationOnly,
    ExecutionAndPublication
}
</code></pre>
<p><em><strong>None</strong></em>
<code>Lazy&lt;T&gt;</code> 实例不是线程安全的；如果从多个线程访问该实例，则其行为不确定。 仅应在高性能至关重要并且保证决不会从多个线程初始化 <code>Lazy&lt;T&gt;</code> 实例时才使用该模式。 如果您使用指定初始化方法（valueFactory 参数的 <code>Lazy&lt;T&gt;</code> 构造函数，并且如果首次调用 <code>Lazy&lt;T&gt;.Value</code> 属性时，该初始化方法引发异常（或者无法处理异常），则该异常将在 <code>Lazy&lt;T&gt;.Value</code> 属性的后续调用上再次缓存和引发该异常。 如果您使用不指定初始化方法的 <code>Lazy&lt;T&gt;</code> 构造函数，则不会缓存 T 默认构造函数引发的异常。 在这种情况下，随后调用 <code>Lazy&lt;T&gt;.Value</code> 属性可能会成功地初始化 <code>Lazy&lt;T&gt;</code> 实例。 如果初始化方法递归访问 <code>Lazy&lt;T&gt;</code> 实例的 Value 属性，则引发 InvalidOperationException。</p>
<p><em><strong>PublicationOnly</strong></em>
当多个线程尝试同时初始化一个 <code>Lazy&lt;T&gt;</code> 实例时，允许所有线程都运行初始化方法（如果没有初始化方法，则为默认构造函数）。 完成初始化的第一个线程设置 <code>Lazy&lt;T&gt;</code> 实例的值。 该值将返回给同时运行初始化方法的所有其他线程，除非该初始化方法对这些线程引发异常。 争用线程创建的任何 T 实例都将被丢弃。 如果初始化方法对任何线程引发异常，则该异常会从在该线程上的<code>Lazy&lt;T&gt;.Value</code> 属性传播出去。 不缓存该异常。 IsValueCreated 属性的值仍然为 false，并且随后通过其中引发异常的线程或通过其他线程对 Value 属性的调用会导致初始化方法再次运行。 如果初始化方法递归访问 <code>Lazy&lt;T&gt;</code> 实例的 Value 属性，则不会引发异常。</p>
<p><em><strong>ExecutionAndPublication</strong></em>
使用锁来确保只有一个线程可以在线程安全的方式下初始化 <code>Lazy&lt;T&gt;</code> 实例。 如果初始化方法（如果没有初始化方法，则为默认构造函数）在内部使用锁，则可能会发生死锁。 如果您使用指定初始化方法（valueFactory 参数的 <code>Lazy&lt;T&gt;</code> 构造函数，并且如果首次调用 <code>Lazy&lt;T&gt;.Value</code> 属性时，该初始化方法引发异常（或者无法处理异常），则该异常将在 <code>Lazy&lt;T&gt;.Value</code> 属性的后续调用上再次缓存和引发该异常。 如果您使用不指定初始化方法的 <code>Lazy&lt;T&gt;</code> 构造函数，则不会缓存 T 默认构造函数引发的异常。 在这种情况下，随后调用 <code>Lazy&lt;T&gt;.Value</code> 属性可能会成功地初始化 <code>Lazy&lt;T&gt;</code> 实例。 如果初始化方法递归访问 <code>Lazy&lt;T&gt;</code> 实例的 Value 属性，则引发 InvalidOperationException。</p>
<p>具体可参考下面链接
<a href="http://msdn.microsoft.com/en-us/library/system.threading.lazythreadsafetymode%28VS.100%29.aspx">http://msdn.microsoft.com/en-us/library/system.threading.lazythreadsafetymode%28VS.100%29.aspx</a></p>
]]></content>
    </entry>
</feed>