<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://songsong.org</id>
    <title>陈仁松博客</title>
    <updated>2019-05-27T15:34:38.103Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://songsong.org"/>
    <link rel="self" href="https://songsong.org/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://songsong.org/images/avatar.png</logo>
    <icon>https://songsong.org/favicon.ico</icon>
    <rights>All rights reserved 2019, 陈仁松博客</rights>
    <entry>
        <title type="html"><![CDATA[常用正则表达式汇总]]></title>
        <id>https://songsong.org/post/regex-common</id>
        <link href="https://songsong.org/post/regex-common">
        </link>
        <updated>2016-03-27T15:33:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-校验数字的表达式">1. 校验数字的表达式</h2>
<p>1.1 数字：<code>^[0-9]*$</code>
1.2 n位的数字：<code>^\d{n}$</code>
1.3 至少n位的数字：<code>^\d{n,}$</code>
1.4 m-n位的数字：<code>^\d{m,n}$</code>
1.5 零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code>
1.6 非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]{1,2})?$</code>
1.7 带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d{1,2})?$</code>
1.8 正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code>
1.9 有两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code>
1.10 有1~3位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code>
1.11 非零的正整数：<code>^[1-9]\d*$</code> 或 <code>^([1-9][0-9]*){1,3}$</code> 或 <code>^\+?[1-9][0-9]*$</code>
1.12 非零的负整数：<code>^\-[1-9][]0-9&quot;*$</code> 或 <code>^-[1-9]\d*$</code>
1.13 非负整数：<code>^\d+$</code> 或 <code>^[1-9]\d*|0$</code>
1.14 非正整数：<code>^-[1-9]\d*|0$</code> 或 <code>^((-\d+)|(0+))$</code>
1.15 非负浮点数：<code>^\d+(\.\d+)?$</code> 或 <code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code>
1.16 非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code> 或 <code>^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code>
1.17 正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code> 或 <code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code>
1.18 负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code> 或 <code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code>
1.19 浮点数：<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></p>
<h2 id="2-校验字符的表达式">2. 校验字符的表达式</h2>
<p>2.1 汉字：<code>^[\u4e00-\u9fa5]{0,}$</code>
2.2 英文和数字：<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]{4,40}$</code>
2.3 长度为3-20的所有字符：<code>^.{3,20}$</code>
2.4 由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code>
2.5 由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code>
2.6 由26个小写英文字母组成的字符串：<code>^[a-z]+$</code>
2.7 由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code>
2.8 由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$</code> 或 <code>^\w{3,20}$</code>
2.9 中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code>
2.10 中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</code>
2.11 可以输入含有^%&amp;<code>,;=?$\&quot;等字符：</code>[^%&amp;<code>,;=?$\x22]+</code>
2.12 禁止输入含有~的字符：<code>[^~\x22]+</code></p>
<h2 id="3-特殊需求表达式">3. 特殊需求表达式</h2>
<p>3.1 Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code>
3.2 域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</code>
3.3 InternetURL：<code>[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code>
3.4 手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</code>
3.5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：<code>^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$</code>
3.6 国内电话号码(0511-4405222、021-87888822)：<code>\d{3}-\d{8}|\d{4}-\d{7}</code>
3.7 身份证号：
3.7.1 15位或18位身份证：<code>^\d{15}|\d{18}$</code>
3.7.2 15位身份证：<code>^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$</code>
3.7.3 18位身份证：<code>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</code>
3.8 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code>
3.9 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w{5,17}$</code>
3.10 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code>
3.11 日期格式：<code>^\d{4}-\d{1,2}-\d{1,2}</code>
3.12 一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code>
3.13 一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code>
3.14 xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code>
3.15 中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code>
3.16 双字节字符：<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
3.17 空白行的正则表达式：<code>\n\s*\r</code> (可以用来删除空白行)
3.18 HTML标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
3.19 首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
3.20 腾讯QQ号：<code>[1-9][0-9]{4,}</code> (腾讯QQ号从10000开始)
3.21 中国邮政编码：<code>[1-9]\d{5}(?!\d)</code> (中国邮政编码为6位数字)
3.22 IPV4地址：<code>\d+\.\d+\.\d+\.\d+</code> (提取IPV4地址时有用)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抓取RTMP视频&音频数据]]></title>
        <id>https://songsong.org/post/rtmp-capture</id>
        <link href="https://songsong.org/post/rtmp-capture">
        </link>
        <updated>2015-10-24T10:26:19.000Z</updated>
        <content type="html"><![CDATA[<p>需要的工具：抓包工具（这里我使用的是<code>WireShark</code>）、<code>Rtmpdump</code></p>
<p>一开始我思路是想分析下html查看下是否有直接的下载地址：
<img src="https://songsong.org/post-images/1558970800340.png" alt="">
查询到了meta.xml,在里面发现了stream的path，这时候发现是rtmp的无法直接下载， 于是想到使用WireShark工具抓包,利用meta.xml里面的 cp11276.edgefcs.net/ondemand ，首先ping 获取ip
<img src="https://songsong.org/post-images/1558970807504.png" alt="">
得到96.17.102.28，通过过滤ip得到下面rtmp的信息
<img src="https://songsong.org/post-images/1558970820436.png" alt=""></p>
<p>url:</p>
<pre><code>rtmp://96.17.102.28/ondemand?_fcs_vhost=cp11276.edgefcs.net
</code></pre>
<p>path:</p>
<pre><code>mp3:media.thomson-webcast.net/index=/1/4/2/5/3/3/6/2/0/0/~/m/instances/8qfcz37z/items/5wurmfcb/clips/dvzgs4dr/0/clip?itemview=b8cchdaae5q3bafgzebcqk55w55m2g4sqc2f68z2nckpafpx_105059808&amp;mmc_installation=mmc_production&amp;mmc_installation_type=prod
</code></pre>
<p>在RtmpDump下面执行</p>
<pre><code>rtmpdump -r &quot;rtmp://96.17.102.28/ondemand?_fcs_vhost=cp11276.edgefcs.net&quot; -y &quot;mp3:media.thomson-webcast.net/index=/1/4/2/5/3/3/6/2/0/0/~/m/instances/8qfcz37z/items/5wurmfcb/clips/dvzgs4dr/0/clip?itemview=b8cchdaae5q3bafgzebcqk55w55m2g4sqc2f68z2nckpafpx_105059808&amp;mmc_installation=mmc_production&amp;mmc_installation_type=prod&quot; -o webcast.mp3
</code></pre>
<p><img src="https://songsong.org/post-images/1558970970320.png" alt="">
下载成功得到webcast.mp3</p>
<p><img src="https://songsong.org/post-images/1558970974335.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#基础 - Lazy<T>]]></title>
        <id>https://songsong.org/post/c-lazy</id>
        <link href="https://songsong.org/post/c-lazy">
        </link>
        <updated>2015-03-18T10:18:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-lazyt-概述">1. <code>Lazy&lt;T&gt;</code> 概述</h2>
<p>往往有这样的情景，我们需要创建一个大对象，这样的对象往往需要较长的时间和较多的空间，为了避免在每次运行时创建这种家伙，在.NET Framework 4 后提供一种便捷的方式：<code>Lazy&lt;T&gt;</code>（称之为懒对象）。</p>
<h2 id="2-lazyt-的使用">2. <code>Lazy&lt;T&gt;</code> 的使用</h2>
<p>我们就来看下Lazy<T>如何使用。</p>
<pre><code>
[Serializable]
class Large
{
    public Large() { }
    public void Test()
    {
        Console.WriteLine(&quot;Test&quot;);
    }
}

</code></pre>
<p>上面代码定义了一个<code>Large</code>对象</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Lazy&lt;Large&gt; lazyObject = new Lazy&lt;Large&gt;();
        Console.WriteLine(lazyObject.IsValueCreated);
        lazyObject.Value.Test();
        Console.WriteLine(lazyObject.IsValueCreated);
    }
}
</code></pre>
<p>在<code>Main</code>函数中进行执行，运行结果如下：</p>
<pre><code>False
Test
True
</code></pre>
<p>这个例子很简单，也是Lazy<T>最基本，也是最常用的应用方式，<code>Lazy&lt;T&gt;</code>实现了按需延迟加载</p>
<h2 id="3-实现自己的lazyt">3. 实现自己的<code>Lazy&lt;T&gt;</code></h2>
<p>在.NET Framework 4.0之前，来看看我们是怎么样定义Lazy<T>的吧。</p>
<pre><code>class MyLazy&lt;T&gt; where T : new()
{
    private T value;
    private bool isLoaded;
    public MyLazy()
    {
        isLoaded = false;
    }
    public T Value
    {
        get
        {
            if (!isLoaded)
            {
                value = new T();
                isLoaded = true;
            }
            return value;
        }
    }
}
</code></pre>
<p>这应该是最简单版本的Lazy<T>了，没有线程安全检测，只有着访问时创建对象，可是对于我们一般的应用来说也许就已经足够了，大家也可以读下老赵写的 <a href="http://www.cnblogs.com/JeffreyZhao/archive/2009/09/07/standard-lazy-proxy.html">较为理想的延迟代理的编写方式</a></p>
<h2 id="4-lazyt的net-framework实现">4. <code>Lazy&lt;T&gt;</code>的.NET Framework实现</h2>
<p>其实.NET Framework和上面的实现大同小异，有两点主要的不同：</p>
<h3 id="a-引入了boxed内部类">A. 引入了Boxed内部类：</h3>
<pre><code>[Serializable]
private class Boxed
{
    // Fields
    internal T m_value;

    // Methods
    [TargetedPatchingOptOut(&quot;Performance critical to inline this type of method across NGen image boundaries&quot;)]
    internal Boxed(T value)
    {
        this.m_value = value;
    }
}
</code></pre>
<p>该内部类取代了我在上面实现中的泛型约束，使之更通用。</p>
<p>但是也应该要注意，如果T为结构体，那么由于T很大，所以装箱拆箱反而也许是个更耗费效率的事情，因此，对值类型慎用<code>Lazy&lt;T&gt;</code>。</p>
<h3 id="b-线程安全的控制">B. 线程安全的控制</h3>
<p>在线程安全的控制选项中，.NET Framework为我们提供了这样的枚举选项：</p>
<pre><code>public enum LazyThreadSafetyMode
{
    None,
    PublicationOnly,
    ExecutionAndPublication
}
</code></pre>
<p><em><strong>None</strong></em>
<code>Lazy&lt;T&gt;</code> 实例不是线程安全的；如果从多个线程访问该实例，则其行为不确定。 仅应在高性能至关重要并且保证决不会从多个线程初始化 <code>Lazy&lt;T&gt;</code> 实例时才使用该模式。 如果您使用指定初始化方法（valueFactory 参数的 <code>Lazy&lt;T&gt;</code> 构造函数，并且如果首次调用 <code>Lazy&lt;T&gt;.Value</code> 属性时，该初始化方法引发异常（或者无法处理异常），则该异常将在 <code>Lazy&lt;T&gt;.Value</code> 属性的后续调用上再次缓存和引发该异常。 如果您使用不指定初始化方法的 <code>Lazy&lt;T&gt;</code> 构造函数，则不会缓存 T 默认构造函数引发的异常。 在这种情况下，随后调用 <code>Lazy&lt;T&gt;.Value</code> 属性可能会成功地初始化 <code>Lazy&lt;T&gt;</code> 实例。 如果初始化方法递归访问 <code>Lazy&lt;T&gt;</code> 实例的 Value 属性，则引发 InvalidOperationException。</p>
<p><em><strong>PublicationOnly</strong></em>
当多个线程尝试同时初始化一个 <code>Lazy&lt;T&gt;</code> 实例时，允许所有线程都运行初始化方法（如果没有初始化方法，则为默认构造函数）。 完成初始化的第一个线程设置 <code>Lazy&lt;T&gt;</code> 实例的值。 该值将返回给同时运行初始化方法的所有其他线程，除非该初始化方法对这些线程引发异常。 争用线程创建的任何 T 实例都将被丢弃。 如果初始化方法对任何线程引发异常，则该异常会从在该线程上的<code>Lazy&lt;T&gt;.Value</code> 属性传播出去。 不缓存该异常。 IsValueCreated 属性的值仍然为 false，并且随后通过其中引发异常的线程或通过其他线程对 Value 属性的调用会导致初始化方法再次运行。 如果初始化方法递归访问 <code>Lazy&lt;T&gt;</code> 实例的 Value 属性，则不会引发异常。</p>
<p><em><strong>ExecutionAndPublication</strong></em>
使用锁来确保只有一个线程可以在线程安全的方式下初始化 <code>Lazy&lt;T&gt;</code> 实例。 如果初始化方法（如果没有初始化方法，则为默认构造函数）在内部使用锁，则可能会发生死锁。 如果您使用指定初始化方法（valueFactory 参数的 <code>Lazy&lt;T&gt;</code> 构造函数，并且如果首次调用 <code>Lazy&lt;T&gt;.Value</code> 属性时，该初始化方法引发异常（或者无法处理异常），则该异常将在 <code>Lazy&lt;T&gt;.Value</code> 属性的后续调用上再次缓存和引发该异常。 如果您使用不指定初始化方法的 <code>Lazy&lt;T&gt;</code> 构造函数，则不会缓存 T 默认构造函数引发的异常。 在这种情况下，随后调用 <code>Lazy&lt;T&gt;.Value</code> 属性可能会成功地初始化 <code>Lazy&lt;T&gt;</code> 实例。 如果初始化方法递归访问 <code>Lazy&lt;T&gt;</code> 实例的 Value 属性，则引发 InvalidOperationException。</p>
<p>具体可参考下面链接
<a href="http://msdn.microsoft.com/en-us/library/system.threading.lazythreadsafetymode%28VS.100%29.aspx">http://msdn.microsoft.com/en-us/library/system.threading.lazythreadsafetymode%28VS.100%29.aspx</a></p>
]]></content>
    </entry>
</feed>