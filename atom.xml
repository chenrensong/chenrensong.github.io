<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://songsong.org</id>
    <title>陈仁松博客</title>
    <updated>2019-05-27T16:00:43.398Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://songsong.org"/>
    <link rel="self" href="https://songsong.org/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://songsong.org/images/avatar.png</logo>
    <icon>https://songsong.org/favicon.ico</icon>
    <rights>All rights reserved 2019, 陈仁松博客</rights>
    <entry>
        <title type="html"><![CDATA[.net core 丢失 api-ms-win-crt-runtime-l1-1-0.dll]]></title>
        <id>https://songsong.org/post/net-core-api-ms-win-crt-runtime-l1-1-0-dll</id>
        <link href="https://songsong.org/post/net-core-api-ms-win-crt-runtime-l1-1-0-dll">
        </link>
        <updated>2018-04-03T15:59:38.000Z</updated>
        <content type="html"><![CDATA[<p>今天在服务器上安装完.net core，执行的时候发现提示丢失<code>api-ms-win-crt-runtime-l1-1-0.dll</code>写下解决过程给大家来参考</p>
<p>api-ms-win-crt-runtime是MFC的运行时环境的库，.net core底层会用到微软提供的C++库和runtime库，这时候安装<code>Visual C++ Redistributable for Visual Studio 2015</code>组件即可解决此问题。</p>
<p>下载地址：<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=48145">https://www.microsoft.com/zh-cn/download/details.aspx?id=48145</a></p>
<p>如果无法解决，可以在<code>C:\Windows\System32</code>和<code>C:\Windows\SysWOW64</code>目录检查下是否有<code>api-ms-win-crt-runtime-l1-1-0.dll</code>删除后重试即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ASP.NET Core  'Microsoft.Win32.Registry' 错误修复]]></title>
        <id>https://songsong.org/post/aspnet-core-microsoftwin32registry</id>
        <link href="https://songsong.org/post/aspnet-core-microsoftwin32registry">
        </link>
        <updated>2018-04-01T15:59:11.000Z</updated>
        <content type="html"><![CDATA[<p>今天在发布Asp.net Core应用到Azure的时候出现错误<code>InvalidOperationException: Cannot find compilation library location for package ‘Microsoft.Win32.Registry’</code>
具体信息如下</p>
<pre><code>2018-04-01 12:44:37.141 +00:00 [Fatal] Hosting startup assembly exception
System.InvalidOperationException: Startup assembly Microsoft.AspNetCore.AzureKeyVault.HostingStartup failed to execute. See the inner exception for more details. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.AspNetCore.AzureKeyVault.HostingStartup, Culture=neutral, PublicKeyToken=null'. The system cannot find the file specified.
   at System.Reflection.RuntimeAssembly._nLoad(AssemblyName fileName, String codeBase, Evidence assemblySecurity, RuntimeAssembly locationHint, StackCrawlMark&amp; stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, Boolean suppressSecurityChecks, IntPtr ptrLoadContextBinder)
   at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark&amp; stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, IntPtr ptrLoadContextBinder)
   at System.Reflection.Assembly.Load(AssemblyName assemblyRef)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   --- End of inner exception stack trace ---
2018-04-01 12:44:39.531 +00:00 [Error] Connection id &quot;&quot;0HLCNPPA0GHOF&quot;&quot;, Request id &quot;&quot;0HLCNPPA0GHOF:00000002&quot;&quot;: An unhandled exception was thrown by the application.
System.InvalidOperationException: Cannot find compilation library location for package 'Microsoft.Win32.Registry'
   at Microsoft.Extensions.DependencyModel.CompilationLibrary.ResolveReferencePaths(ICompilationAssemblyResolver resolver, List`1 assemblies)
   at Microsoft.Extensions.DependencyModel.CompilationLibrary.ResolveReferencePaths()
   at Microsoft.AspNetCore.Mvc.ApplicationParts.AssemblyPart.&lt;&gt;c.&lt;GetReferencePaths&gt;b__8_0(CompilationLibrary library)
   at System.Linq.Enumerable.SelectManySingleSelectorIterator`2.MoveNext()
   at Microsoft.AspNetCore.Mvc.Razor.Compilation.MetadataReferenceFeatureProvider.PopulateFeature(IEnumerable`1 parts, MetadataReferenceFeature feature)
   at Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature)
   at Microsoft.AspNetCore.Mvc.Razor.Internal.DefaultRazorReferenceManager.GetCompilationReferences()
   at System.Threading.LazyInitializer.EnsureInitializedCore[T](T&amp; target, Boolean&amp; initialized, Object&amp; syncLock, Func`1 valueFactory)
   at System.Threading.LazyInitializer.EnsureInitialized[T](T&amp; target, Boolean&amp; initialized, Object&amp; syncLock, Func`1 valueFactory)
   at Microsoft.AspNetCore.Mvc.Razor.Internal.DefaultRazorReferenceManager.get_CompilationReferences()
   at Microsoft.AspNetCore.Mvc.Razor.Internal.LazyMetadataReferenceFeature.get_References()
   at Microsoft.CodeAnalysis.Razor.CompilationTagHelperFeature.GetDescriptors()
   at Microsoft.AspNetCore.Razor.Language.DefaultRazorTagHelperBinderPhase.ExecuteCore(RazorCodeDocument codeDocument)
   at Microsoft.AspNetCore.Razor.Language.RazorEnginePhaseBase.Execute(RazorCodeDocument codeDocument)
   at Microsoft.AspNetCore.Razor.Language.DefaultRazorEngine.Process(RazorCodeDocument document)
   at Microsoft.AspNetCore.Razor.Language.RazorTemplateEngine.GenerateCode(RazorCodeDocument codeDocument)
   at Microsoft.AspNetCore.Mvc.Razor.Internal.RazorViewCompiler.CompileAndEmit(String relativePath)
   at Microsoft.AspNetCore.Mvc.Razor.Internal.RazorViewCompiler.CreateCacheEntry(String normalizedPath)
</code></pre>
<p>经过一番测试后，发现如果<code>.csproj</code>文件包含嵌入的资源，需要将Razor的预编译关闭</p>
<pre><code>&lt;PropertyGroup&gt;        
    &lt;MvcRazorExcludeRefAssembliesFromPublish&gt;false&lt;/MvcRazorExcludeRefAssembliesFromPublish&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>修改后再次发布解决此问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 动态创建类]]></title>
        <id>https://songsong.org/post/typescript-dynamically-class</id>
        <link href="https://songsong.org/post/typescript-dynamically-class">
        </link>
        <updated>2018-03-28T15:58:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="首先定义一个greeter的类">首先定义一个Greeter的类</h3>
<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}

</code></pre>
<h3 id="根据字符串动态创建greeter类">根据字符串动态创建Greeter类</h3>
<pre><code>
//instance creation here
var greeter = Object.create(window[&quot;Greeter&quot;].prototype);
greeter.constructor.apply(greeter, new Array(&quot;World&quot;));

var button = document.createElement('button');
button.innerText = &quot;Say Hello&quot;;
button.onclick = function() {
    alert(greeter.greet());
}

document.body.appendChild(button);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ASP.NET Core 在 Azure 开启 HTTPS]]></title>
        <id>https://songsong.org/post/aspnet-core-azure-https</id>
        <link href="https://songsong.org/post/aspnet-core-azure-https">
        </link>
        <updated>2018-03-18T15:58:15.000Z</updated>
        <content type="html"><![CDATA[<p>前一段博客在百度云上明明已经备案过了，但是<strong>百度云</strong>却检测出没有备案，不知道是什么原因，导致网站一直不能访问，无奈我又将博客迁移到了Azure，这篇教程主要和大家介绍下在Azure上如何开启HTTPS。</p>
<p>首先打开 应用程序服务 - 选中你的应用 （我这里是chenrensong） - SSL证书，导入一个私有证书，导入成功后就会如下图所示显示出来。
<img src="/data/2017/2/ssl_1.png" alt=""></p>
<p>再添加SSL绑定域名，我这里绑定了chenrensong.com 以及 www.chenrensong.com
<img src="/data/2017/2/ssl_2.png" alt=""></p>
<p>到这里在Azure的配置基本算完成了，如果你使用ASP.NET Core作为网站框架，还需要在Startup.cs文件的<code>ConfigureServices</code>方法中配置强制HTTPS服务。</p>
<pre><code>mvcBuilder.AddMvcOptions(options =&gt; options.Filters.Add(new RequireHttpsAttribute()));
</code></pre>
<p>到这里，HTTPS服务就配置完成了，但是我发现<code>https://</code>服务还是无法使用，仔细检查发现原来是百度云加速搞的鬼....免费版不支持HTTPS加速，于是关闭加速服务才解决此问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序.wxapkg文件分析]]></title>
        <id>https://songsong.org/post/unwxapkg</id>
        <link href="https://songsong.org/post/unwxapkg">
        </link>
        <updated>2018-01-23T15:57:35.000Z</updated>
        <content type="html"><![CDATA[<p>前一段时间“跳一跳”很火，朋友圈老刷不上名次，于是了解小程序大致的实现原理，写了wxapkg的反编译工具，目前可以基本还原小程序源码。</p>
<p>那么哪里可以找到小程序的安装包？</p>
<p>1、 <a href="https://servicewechat.com/weapp/release/$%7Bappid%7D/$%7Bversion_num%7D.wxapkg"><s>https://servicewechat.com/weapp/release/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>a</mi><mi>p</mi><mi>p</mi><mi>i</mi><mi>d</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{appid}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span><span class="mord">/</span></span></span></span>{version_num}.wxapkg</s></a></p>
<p>2、在android手机中/data/data/com.tencent.mm/MicroMsg/${userid}/appband/pkg</p>
<p>找到安装包后，源码就在里面，那么要怎么来解析？</p>
<p><img src="/data/2018/1/wxapkgstruct.png" alt=""></p>
<p>我整理了wxapkg文件格式，写了一款解压工具<a href="https://github.com/chenrensong/SS.UnWxapkg">SS.UnWxapkg</a>，核心代码如下</p>
<pre><code class="language-public">    {
        public static void UnWxapkg(string filePath)
        {

            var bytes = File.ReadAllBytes(filePath);

            ByteBuffer byteBuffer = ByteBuffer.Allocate(bytes);

            var firstMark = byteBuffer.ReadByte();
            Console.WriteLine($&quot;first header mark = {firstMark}&quot;);

            var info1 = byteBuffer.ReadInt();
            Console.WriteLine($&quot;info1 = {info1}&quot;);

            var indexInfoLength = byteBuffer.ReadInt();
            Console.WriteLine($&quot;indexInfoLength = {indexInfoLength}&quot;);

            var bodyInfoLength = byteBuffer.ReadInt();
            Console.WriteLine($&quot;bodyInfoLength = {bodyInfoLength}&quot;);

            var lastMark = byteBuffer.ReadByte();
            Console.WriteLine($&quot;last header mark = {lastMark}&quot;);

            if (firstMark != 0xBE || lastMark != 0xED)
            {
                Console.WriteLine(&quot;its not a wxapkg file!&quot;);
            }

            var fileCount = byteBuffer.ReadInt();
            Console.WriteLine($&quot;fileCount = {fileCount}&quot;);

            var fileList = new List&lt;WxapkgFile&gt;();

            for (int i = 0; i &lt; fileCount; i++)
            {
                var nameLen = byteBuffer.ReadInt();
                byte[] nameByte = new byte[nameLen];
                byteBuffer.ReadBytes(nameByte, 0, nameLen);
                var name = Encoding.UTF8.GetString(nameByte);
                var offset = byteBuffer.ReadInt();
                var size = byteBuffer.ReadInt();
                var wxapkgFile = new WxapkgFile() { Name = name, NameLen = nameLen, Offset = offset, Size = size };
                fileList.Add(wxapkgFile);
                Console.WriteLine($&quot;readFile = {name} at Offset = {offset}&quot;);
            }
            var rootPath = System.Environment.CurrentDirectory;
            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(filePath);
            Console.WriteLine($&quot;rootPath = {rootPath}&quot;);
            Console.WriteLine($&quot;fileNameWithoutExtension = {fileNameWithoutExtension}&quot;);

            var unzipPath = Path.Combine(rootPath, fileNameWithoutExtension);
            Console.WriteLine($&quot;unzipPath = {unzipPath}&quot;);
            if (!Directory.Exists(unzipPath))
            {
                Directory.CreateDirectory(unzipPath);
            }

            foreach (var wxapkgFile in fileList)
            {
                var wxapkgFileName = unzipPath + wxapkgFile.Name.Replace('/', Path.DirectorySeparatorChar);
                Console.WriteLine($&quot;wxapkgFileName = {wxapkgFileName}&quot;);
                var directoryName = Path.GetDirectoryName(wxapkgFileName);
                Console.WriteLine($&quot;directoryName = {directoryName}&quot;);
                if (!Directory.Exists(directoryName))
                {
                    Directory.CreateDirectory(directoryName);
                }
                byteBuffer.SetReaderIndex(wxapkgFile.Offset);
                var fileBytes = new byte[wxapkgFile.Size];
                byteBuffer.ReadBytes(fileBytes, 0, fileBytes.Length);
                File.WriteAllBytes(wxapkgFileName, fileBytes);
            }

        }
    }

</code></pre>
<p>代码大意是</p>
<p>1、根据firstMark和lastMark来判断是否是小程序的wxapkg文件格式</p>
<p>2、获取索引段长度、数据段长度、以及文件数量</p>
<p>3、根据文件数量，顺序读取文件数据区，读取每个文件</p>
<p>解压出来的格式基本上如下</p>
<p>│  app-config.json</p>
<p>│  app-service.js</p>
<p>│  page-frame.html</p>
<p>│</p>
<p>├─images</p>
<p>│      hello.png</p>
<p>│      world.png</p>
<p>│</p>
<p>├─pages</p>
<p>│       gameover.html</p>
<p>│       index.html</p>
<p>│       play.html</p>
<p>│       web.html</p>
<p>根据解压出来的文件进行分析可以得出下列信息
<img src="/data/2018/1/wxapkgInfo.png" alt=""></p>
<p>按照上面信息对应解析基本上就能得到源码了。</p>
<p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UWP基础教程 - 调起应用的几种方法]]></title>
        <id>https://songsong.org/post/uwp-schema-console</id>
        <link href="https://songsong.org/post/uwp-schema-console">
        </link>
        <updated>2018-01-10T15:56:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-使用uwp的launcher-api">1. 使用UWP的Launcher API</h2>
<pre><code>var uri = new Uri(&quot;protocolname:&quot;);
bool success = await Windows.System.Launcher.LaunchUriAsync(uri);
</code></pre>
<p>参考：<a href="https://blogs.windows.com/buildingapps/2017/01/25/calling-windows-10-apis-desktop-application/#FoKcZI8LRWhiomD2.97">Calling Windows 10 APIs From a Desktop Application</a></p>
<h2 id="2使用packagemanager也是uwp的api">2.使用PackageManager，也是UWP的API</h2>
<pre><code>var manager = new PackageManager();
var p = manager.FindPackagesForUser(&quot;&quot;, PackageFamilyName);
var ls = await p.ToList()[0].GetAppListEntriesAsync();
foreach (var item in ls)
{
    await item.LaunchAsync();
}
</code></pre>
<h2 id="3使用process调用protocolname">3.使用Process调用protocolname</h2>
<pre><code>Process.Start(new ProcessStartInfo(&quot;protocolname:&quot;));
</code></pre>
<h2 id="4使用命令行">4.使用命令行</h2>
<pre><code>&gt;start bingnews:
&gt;start myapplication:protocol-parameter
&gt;start myapplication://single-player/level3?godmode=1&amp;ammo=200
</code></pre>
<p>参考：<a href="https://docs.microsoft.com/zh-cn/windows/uwp/xbox-apps/automate-launching-uwp-apps#a-nameaccepting-argumentsa">自动启动 Windows 10 UWP 应用</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Windows下安装TensorFlow]]></title>
        <id>https://songsong.org/post/windows-tensorflow</id>
        <link href="https://songsong.org/post/windows-tensorflow">
        </link>
        <updated>2017-12-03T15:56:10.000Z</updated>
        <content type="html"><![CDATA[<p>目前TensorFlow在Windows下只支持Python 3.x。</p>
<h2 id="1下载python">1.下载Python</h2>
<h3 id="首先安装pythone-364">首先安装Pythone 3.6.4</h3>
<p><a href="https://www.python.org/downloads/release/python-364/">下载地址</a></p>
<h3 id="升级pip">升级pip</h3>
<pre><code>python.exe -m pip install --upgrade pip
</code></pre>
<h2 id="安装tensorflow">安装tensorflow</h2>
<h3 id="cpu版本">CPU版本</h3>
<pre><code>pip install --upgrade tensorflow
</code></pre>
<h3 id="gpu版本">GPU版本</h3>
<pre><code>pip install --upgrade tensorflow-gpu
</code></pre>
<h3 id="安装tensorflow的gpu支持包">安装TensorFlow的GPU支持包</h3>
<h4 id="安装cuda-toolkit-91">安装CUDA Toolkit 9.1</h4>
<p><a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a></p>
<h4 id="安装cudnn-71">安装cuDNN 7.1</h4>
<p><a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a></p>
<pre><code>$ python
...
&gt;&gt;&gt; import tensorflow as tf
&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow!')
&gt;&gt;&gt; sess = tf.Session()
&gt;&gt;&gt; print(sess.run(hello))
Hello, TensorFlow!
&gt;&gt;&gt; a = tf.constant(1)
&gt;&gt;&gt; b = tf.constant(2)
&gt;&gt;&gt; print(sess.run(a + b))
3
&gt;&gt;&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【译】使用 dotnet watch 开发 ASP.NET Core 应用]]></title>
        <id>https://songsong.org/post/dotnet-watch-aspnet-core</id>
        <link href="https://songsong.org/post/dotnet-watch-aspnet-core">
        </link>
        <updated>2017-11-28T15:55:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p><code>dotnet watch</code> 是一个开发阶段在源文件发生变动的情况下使用 <code>dotnet</code> 命令的工具。 当代码发生变动的时候可以用来执行编译，运行测试，或者发布操作。</p>
<p>在本教程中，我们将使用一个现有的计算两个数字之和以及乘积的 WebApi 应用程序来演示如何使用 <code>dotnet watch</code> 。示例应用程序故意包含一个错误，作为本教程的一部分我们会修复它。</p>
<h2 id="开始入门">开始入门</h2>
<p>开始下载 <a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/tutorials/dotnet-watch/sample">示例程序</a>。示例程序包含两个项目， <code>WebApp</code> （Web 应用程序）以及 <code>WebAppTests</code> （Web 应用程序配套的单元测试项目）</p>
<p>在命令行控制台中，进入下载示例程序的目录并且运行下述命令：</p>
<p>1、<code>dotnet restore</code>
2、<code>cd WebApp</code>
3、<code>dotnet run</code></p>
<p>控制台输出将显示如下信息，表明该应用程序正在运行并等待请求：</p>
<pre><code>$ dotnet run
Hosting environment: Development
Content root path: C:/Docs/aspnetcore/tutorials/dotnet-watch/sample/WebApp
Now listening on: http://localhost:5000
Application started. Press Ctrl+C to shut down.
</code></pre>
<p>在 Web 浏览器中，导航到 <code>http://localhost:5000/api/math/sum?a=4&amp;b=5</code> 页面你会看到结果 <code>9</code> 。</p>
<p>如果你导航到 <code>http://localhost:5000/api/math/product?a=4&amp;b=5</code> 页面，你期望得到结果 <code>20</code>。但是实际上还是返回了 <code>9</code> 。</p>
<p>我们会修复这个问题的。</p>
<h2 id="项目中添加-dotnet-watch">项目中添加 <code>dotnet watch</code></h2>
<p>1、按照下面例子的方式在 WebApp/project.json 文件的 <code>tools</code> 配置节中添加 <code>Microsoft.DotNet.Watcher.Tools</code> 引用：</p>
<pre><code>&lt;ItemGroup&gt;
    &lt;DotNetCliToolReference Include=&quot;Microsoft.DotNet.Watcher.Tools&quot; Version=&quot;2.0.0&quot; /&gt;
&lt;/ItemGroup&gt; 
</code></pre>
<p>2、运行 <code>dotnet restore</code>。</p>
<p>控制台输出将显示如下信息：</p>
<div id="code_2" class="codeCloneBtn">复制代码</div>
<pre><code>log  : Restoring packages for /Users/user/dev/aspnet/Docs/aspnet/tutorials/dotnet-watch/sample/WebApp/project.json...
log  : Restoring packages for tool 'Microsoft.DotNet.Watcher.Tools' in /Users/user/dev/aspnet/Docs/aspnet/tutorials/dotnet-watch/sample/WebApp/project.json...
log  : Installing Microsoft.DotNet.Watcher.Core 1.0.0-preview2-final.
log  : Installing Microsoft.DotNet.Watcher.Tools 1.0.0-preview2-final.
</code></pre>
<h2 id="使用-dotnet-watch-运行-dotnet-命令">使用 <code>dotnet watch</code> 运行 <code>dotnet</code> 命令</h2>
<p>任何与 <code>dotnet</code> 有关的命令都可以以 <code>dotnet watch</code> 这样的方式运行：例如：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>带上 watch 的命令Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dotnet run</code></td>
<td><code>dotnet watch run</code></td>
</tr>
<tr>
<td><code>dotnet run -f netcoreapp2.0</code></td>
<td><code>dotnet watch run -f netcoreapp2.0</code></td>
</tr>
<tr>
<td><code>dotnet run -f netcoreapp2.0-- --arg1</code></td>
<td><code>dotnet watch run -f netcoreapp2.0-- --arg1</code></td>
</tr>
<tr>
<td><code>dotnet test</code></td>
<td><code>dotnet watch test</code></td>
</tr>
</tbody>
</table>
<p>为了让 <code>WebApp</code> 在 watcher 模式下运行，在 <code>WebApp</code> 目录里面运行 <code>dotnet watch run</code> 命令。 控制台便会监控代码文件变化。</p>
<h2 id="在-dotnet-watch-模式进行修改">在 <code>dotnet watch</code> 模式进行修改</h2>
<p>确保 <code>dotnet watch</code> 在运行中。</p>
<p>让我们来修复上面发现的那个两个数相乘结果错误。</p>
<p>打开文件 WebApp/Controllers/MathController.cs。我们故意在代码中引入了错误。</p>
<pre><code>public static int Product(int a, int b)
{
    // We have an intentional bug here
    // + should be *
    return a + b;//手工高亮
}
</code></pre>
<p>通过把代码 <code>a + b</code> 替换为 <code>a * b</code> 修复错误。</p>
<p>保存文件，验证 <code>http://localhost:5000/api/math/product?a=4&amp;b=5</code> 链接返回正确的结果。</p>
<h2 id="使用-dotnet-watch-运行测试">使用 <code>dotnet watch</code> 运行测试</h2>
<p>1、打开文件 WebApp/Controllers/MathController.cs。撤销原先的修改并保存文件。</p>
<p>2、导航到WebAppTests目录</p>
<p>3、运行<code>dotnet restore</code>命令</p>
<p>4、运行<code>dotnet watch test</code>, 控制台输出将显示如下信息：</p>
<pre><code>Total tests: 2. Passed: 1. Failed: 1. Skipped: 0.
Test Run Failed.
</code></pre>
<p>修改代码，并保存文件。</p>
<p><code>dotnet watch</code> 将会检测到文件变更并且重新运行测试。</p>
<p><strong>查看英文原文</strong>：<a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/dotnet-watch">Developing ASP.NET Core apps using dotnet watch</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C# 7.0 探索之旅]]></title>
        <id>https://songsong.org/post/csharp-7-explore</id>
        <link href="https://songsong.org/post/csharp-7-explore">
        </link>
        <updated>2017-11-25T15:55:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="模式匹配pattern-matching">模式匹配（Pattern matching）</h2>
<p>C# 7.0 引入了模式匹配的概念，一种从抽象的角度来说，指可以测试一个值是否有某种特定的“形状”、并在满足这一条件的时候从值中提取信息的句法元素。</p>
<p>C# 7.0 中的模式的例子有：</p>
<ul>
<li>无序列表c（c 为 C# 中的一个常量表达式）形式的常量模式（Constant pattern），来测试输入是否等于 c</li>
<li>T x（T 为一个类型，x 为一个标识符）形式的类型模式（Type pattern），来测试输入是否有类型 T，并在满足条件的时候将值提取成全新的 T 类型的变量 x</li>
<li>var x（x 为一个标识符）形式的变量匹配（Var patterns），这种匹配总是能够成功，并会将输入的值简单的放入一个全新的与输入类型相同的变量 x 中。</li>
</ul>
<p>这只是个开始——模式现在是 C# 中的一种新的语言元素了，我们也希望在未来能向 C# 中加入更多的模式。</p>
<p>在 C# 7.0 中我们用模式改进了两个已有的语言结构：</p>
<ul>
<li>is 表达式的右边现在可以是表达式，而不仅仅是类型了</li>
<li>switch 语句中的 case 子句现在可以匹配模式，而不仅仅是常量了
在未来的 C# 版本中我们会添加更多可以使用模式的地方。</li>
</ul>
<h2 id="具有模式的-is-表达式">具有模式的 Is 表达式</h2>
<p>这里有一个用常量模式和类型模式来使用 is 表达式的例子：</p>
<pre><code>public void PrintStars(object o)
{
    if (o is null)return;     // 常量模式 “null”
    if (!(o is int i)) return; // 类型模式 “int i”    
    WriteLine(new string('*', i));
} 
</code></pre>
<p>如你所见，模式变量（pattern variables）——通过模式引入的变量——和之前描述过的 out 变量很像，都可以在表达式中声明，也可以在最近的作用域中使用。和 out 变量一样，模式变量也是可以修改的。我们经常以“表达式变量”来统称 out 变量和模式变量。</p>
<p>模式和 Try 模式通常可以被很好地组合使用：</p>
<pre><code>if (o is int i || (o is string s &amp;&amp; int.TryParse(s, out i)) { /* 使用 i */ }
</code></pre>
<h2 id="具有模式的-switch-语句">具有模式的 Switch 语句</h2>
<p>我们正在使 switch 语句一般化，因此：</p>
<p>你可以筛选任意类型（不仅仅是原生类型）</p>
<ul>
<li>模式可以被用在 case 子句中</li>
<li>Case 子句可以有额外的限制条件</li>
<li>这是个简单的例子：</li>
</ul>
<pre><code>switch(shape)
{
    case Circle c:
        WriteLine($&quot;circle with radius {c.Radius}&quot;);
        break;
    case Rectangle s when (s.Length == s.Height):
        WriteLine($&quot;{s.Length} x {s.Height} square&quot;);
        break;
    case Rectangle r:
        WriteLine($&quot;{r.Length} x {r.Height} rectangle&quot;);
        break;
    default:
        WriteLine(&quot;&lt;unknown shape&gt;&quot;);
        break;
    case null:
        throw new ArgumentNullException(nameof(shape));
}
</code></pre>
<p>关于这个新扩展的 switch 语句有一些需要注意的事项：</p>
<ul>
<li>现在 case 子句的顺序变得重要了：就如 catch 子句一样，case 子句不再一定不相交，第一个匹配的项将被选择。因此将正方形的情况（见上图例）放在矩形之前很重要。同样，编译器会帮你标出永远无法到达的分支。在此之前你无法指定计算顺序，因此这不会造成（旧代码）行为的大变化。</li>
<li>default 子句将总是在最后被计算： 即使 null 的情况被放在最后，它仍会在 default 子句被选中之前被检查。这是为了与现存的语义兼容。然而，良好的习惯通常会将 default 子句放在最后。</li>
<li>在最后的 null 子句不会无法到达： 这是因为类型模式（的行为）以目前的 is 表达式为例子，且不会与 null 匹配。这保证了 null 值不会意外地被类型模式抢先匹配；你需要更加明确如何处理它们（或是将它们留给 default 子句）。</li>
</ul>
<p>由 case …: 标签引入的模式变量只在当前的 switch 节有效。</p>
<h2 id="out-变量out-variables">Out 变量（Out variables)</h2>
<p>在之前的 C# 版本中，使用 out 参数并不像我们期盼的那样流畅。在你能够使用 out 参数来调用一个函数之前，你首先需要声明待传入的变量。同时由于你一般不会初始化这些变量（它们毕竟会被这些方法覆写），你也无法使用 var 来声明它们，而是需要指定完整的类型：</p>
<pre><code>public void PrintCoordinates(Point p)
{
    int x, y; // 需要“预声明”
    p.GetCoordinates(out x, out y);
    WriteLine($&quot;({x}, {y})&quot;);
}
</code></pre>
<p>在 C# 7.0 中我们添加了 out 变量；使你能够在传入一个 out 参数的地方声明一个变量：</p>
<pre><code>public void PrintCoordinates(Point p)
{
    p.GetCoordinates(out int x, out int y);
    WriteLine($&quot;({x}, {y})&quot;);
}
</code></pre>
<p>请注意，这些变量位于包含它们的代码块的作用域，因此之后的代码可以使用它们。许多种类的语句不会建立它们自己的代码块，因此在这些语句中声明的 out 变量通常被引入到（这个）封闭作用域中。</p>
<p>由于 out 变量直接以 out 参数的形式声明，编译器通常可以分辨它们的类型应该是什么（除非有冲突的重载），所以完全可以用 var 替代类型来声明它们：</p>
<pre><code>p.GetCoordinates(out var x, out var y);
</code></pre>
<p>Out 参数的一个常见使用场景是会返回一个指示是否成功的 Try… 模式，然后 out 参数来携带获得的结果：</p>
<pre><code>public void PrintStars(string s)
{
    if (int.TryParse(s, out var i)) { WriteLine(new string('*', i)); }
    else { WriteLine(&quot;Cloudy - no stars tonight!&quot;); }
} 
</code></pre>
<p>我们也允许以 _（下划线）形式“舍弃” out 参数，来使你忽略你不关心的参数：</p>
<pre><code>p.GetCoordinates(out var x, out _); // 我只关心 x
</code></pre>
<h2 id="元组tuples">元组（Tuples）</h2>
<p>我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C# 中的选项远远达不到令人满意的程度：</p>
<ul>
<li>Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。</li>
<li>System.Tuple&lt;...&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。</li>
<li>自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。</li>
<li>通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。</li>
</ul>
<p>为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tuple literals）：</p>
<pre><code>(string, string, string) LookupName(long id) // 元组返回类型
{
    ... // 从数据储存中取出第一个、中间和最后一个数据
    return (first, middle, last); // 元组字面量
}
</code></pre>
<p>这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。</p>
<p>方法的调用者将会收到一个元组，并可以分别访问各个元素：</p>
<pre><code>var names = LookupName(id);
WriteLine($&quot;found {names.Item1} {names.Item3}.&quot;);
</code></pre>
<p>Item1 等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法：</p>
<pre><code>(string first, string middle, string last) LookupName(long id) // 元组元素拥有了名称
</code></pre>
<p>现在元组的接收者可以使用更具描述性的名字了：</p>
<pre><code>var names = LookupName(id);
WriteLine($&quot;found {names.first} {names.last}.&quot;);
</code></pre>
<p>你也可以直接在元组字面量中指定元素名称：</p>
<pre><code>    return (first: first, middle: middle, last: last); // 在字面量中命名元组元素
</code></pre>
<p>通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。</p>
<p>元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。</p>
<p>这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。</p>
<p>元组依赖于一族被称为 ValueTuple&lt;...&gt; 的底层泛型结构类型。如果你指向了一个还未包含这些类型的框架，你可以从 Nuget 中获得它们：</p>
<ul>
<li>在解决方案管理器中右击项目并选中“管理 NuGet 程序包”</li>
<li>选择“浏览”标签并将“nuget.org”选为“程序包源”</li>
<li>搜索“System.ValueTuple”并安装它。</li>
</ul>
<h2 id="解构deconstruction">解构（Deconstruction）</h2>
<p>另一个使用元组的方法是去解构它们。一个_解构声明（deconstructing declaration__）_是一种用来将一个元组（或其他值类型)分成许多部分并将这些部分分别转换为全新的变量的语法：</p>
<pre><code>(string first, string middle, string last) = LookupName(id1); // 解构声明
WriteLine($&quot;found {first} {last}.&quot;);
</code></pre>
<p>在一个解构声明中，你可以为独立的变量声明使用 var：</p>
<pre><code>(var first, var middle, var last) = LookupName(id1); // 在内部使用 var
</code></pre>
<p>甚至把一个单独的 var 放在括号外作为缩写：</p>
<pre><code>var (first, middle, last) = LookupName(id1); // 在外部使用 var
</code></pre>
<p>你也可以通过 解构分配（deconstructing assignment）将其解构到已存在的变量上：</p>
<pre><code>(first, middle, last) = LookupName(id2); // 解构分配
</code></pre>
<p>解构不仅仅适用于元组。任何类型都可以被解构，只要它拥有一个如下形式的（实例或扩展）解构方法（deconstructor method）：</p>
<pre><code>public void Deconstruct(out T1 x1, ..., out Tn xn) { ... }
</code></pre>
<p>Out 参数构成解构的结果。</p>
<p>（为什么它使用 out 参数而不是返回一个元组？那是因为这样一来你可以对不同的值的数量拥有不同的重载了）。</p>
<pre><code>class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) { X = x; Y = y; }
    public void Deconstruct(out int x, out int y) { x = X; y = Y; }
}

(var myX, var myY) = GetPoint(); // 调用 Deconstruct(out myX, out myY);
</code></pre>
<p>它将成为一种常见的模式，通过以这种方式“对称地”拥有构造器和解构器。</p>
<p>如同 out 变量，我们允许在解构中“舍弃”你不关心的部分：</p>
<pre><code>(var myX, _) = GetPoint(); // 我只关心 myX
</code></pre>
<h2 id="本地方法local-functions">本地方法（Local functions）</h2>
<p>有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 本地函数（local function）：</p>
<pre><code>public int Fibonacci(int x)
{
    if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x));
    return Fib(x).current;

    (int current, int previous) Fib(int i)
    {
        if (i == 0) return (1, 0);
        var (p, pp) = Fib(i - 1);
        return (p + pp, p);
    }
}
</code></pre>
<p>作用域内的参数和本地变量都在本地方法中可用，就如同在 lambda 表达式中一样。</p>
<p>例如，被实现为迭代器的方法通常需要一个非迭代的包装函数以在调用时检查参数。（迭代器本身在 MoveNext 被调用之前不会开始）。本地方法完美的适用于这种场景：</p>
<pre><code>public IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; filter)
{
    if (source == null) throw new ArgumentNullException(nameof(source));
    if (filter == null) throw new ArgumentNullException(nameof(filter));

    return Iterator();

    IEnumerable&lt;T&gt; Iterator()
    {
        foreach (var element in source) 
        {
            if (filter(element)) { yield return element; }
        }
    }
}
</code></pre>
<p>如果 Iterator 是 Filter 旁的私有函数，它可能会被其他成员意外地直接使用（而没有参数检查）。同时，它还需要接收与 Filter 相同的参数，而不是直接在作用域中使用它们。</p>
<h2 id="字面量改进">字面量改进</h2>
<p>C# 7.0 允许 _（下划线）在数字字面量中作为数字分隔符 （digit separator）：</p>
<pre><code>var d = 123_456;
var x = 0xAB_CD_EF;
</code></pre>
<p>你可以将它们放置在任意位置来增强可读性。它们不会影响值。</p>
<p>同时，C# 7.0 引入了二进制字面量（binary literals），这样你可以直接指定位模板而不用将十六进制记号牢记于心。</p>
<pre><code>var b = 0b1010_1011_1100_1101_1110_1111;
</code></pre>
<h2 id="引用返回和引用本地变量ref-returns-and-locals">引用返回和引用本地变量（Ref returns and locals）</h2>
<p>就像你可以在 C# 中以引用方式传值（使用 ref 修饰符）一样，你现在可以以引用方式返回值，并将它们以引用的方式存在本地变量中。</p>
<pre><code>public ref int Find(int number, int[] numbers)
{
    for (int i = 0; i &lt; numbers.Length; i++)
    {
        if (numbers[i] == number) 
        {
            return ref numbers[i]; // 返回储存的位置，而不是值
        }
    }
    throw new IndexOutOfRangeException($&quot;{nameof(number)} not found&quot;);
}

int[] array = { 1, 15, -39, 0, 7, 14, -12 };
ref int place = ref Find(7, array); // 为 7 在数列中的位置起个别名
place = 9; // 在数列中以 9 替换 7
WriteLine(array[4]); // 输出 9
</code></pre>
<p>这对向很大的数据结构中传递占位符来说非常有用。例如，一个游戏可能将它的数据存在一个庞大的预先分配好的结构体数组（以避免垃圾回收的停顿）中。现在方法可以返回直接指向这种解构的引用，调用者可以借此来读或者修改数据。</p>
<p>为了确保这样做是安全的，有一些限制：</p>
<ul>
<li>你只能返回“可以安全返回”的引用：一种是传给你的，另一种是指向对象中的字段的。</li>
<li>引用本地变量被初始化到一个确定的储存位置，且不可被修改为指向另一个（引用变量）。</li>
</ul>
<h2 id="更加一般化的-async-返回类型">更加一般化的 Async 返回类型</h2>
<p>在此之前，C# 中的 async 方法只能返回 void，Task 或是 Task<T> 中的一个。C# 7.0 允许用这样的方式定义其他的类型以使它们可以从被 async 方法所返回。</p>
<p>例如，我们现在有一个 ValueTask<T> 结构类型。它被用来防止 async 操作的结果在仍在 await 的时候就可用的情况下的 Task<T> 对象的创建。对大多数 async 场景，例如使用到缓存，这可以大幅减少内存分配并可以获得巨大的性能提升。</p>
<p>你可以想象得到，有许多种能使这种“类 Task”类型非常有用的方法。正确的创建它们可能不是那么直观，因此我们并不期待大多数人来造自己的轮子，但是它们将会出现在框架和 API 中，然后调用者们就可以像今天使用 Task 一样地返回并 await 它们了。</p>
<h2 id="更多的表达式体成员expression-bodied-members">更多的表达式体成员（Expression bodied members）</h2>
<p>表达式体方法，属性等是 C# 6.0 中的一大亮点，但我们并未所有成员上启用它。C# 7.0 在可以拥有表达式体的列表中添加了访问器、构造器和析构器：</p>
<pre><code>class Person
{
    private static ConcurrentDictionary&lt;int, string&gt; names = new ConcurrentDictionary&lt;int, string&gt;();
    private int id = GetId();

    public Person(string name) =&gt; names.TryAdd(id, name); // 构造器
    ~Person() =&gt; names.TryRemove(id, out *);              // 析构器
    public string Name
    {
        get =&gt; names[id];                                 // get 访问器
        set =&gt; names[id] = value;                         // set 访问器
    }
}
</code></pre>
<p>这是由社区贡献的特性的一个例子，而不是微软 C# 编译器团队（贡献的）。对，开源！</p>
<h2 id="抛出表达式throw-expressions">抛出表达式（Throw expressions）</h2>
<p>在表达式中抛出异常非常简单：只要调用一个为你做这件事的方法！但是在 C# 7.0 中我们直接允许将 throw 在特定位置作为一个表达式：</p>
<pre><code>class Person
{
    public string Name { get; }
    public Person(string name) =&gt; Name = name ?? throw new ArgumentNullException(nameof(name));
    public string GetFirstName()
    {
        var parts = Name.Split(&quot; &quot;);
        return (parts.Length &gt; 0) ? parts[0] : throw new InvalidOperationException(&quot;No name!&quot;);
    }
    public string GetLastName() =&gt; throw new NotImplementedException();
}
</code></pre>
<p>如果你想了解更多C#的语言特性和发展，可以去<a href="https://github.com/dotnet/csharplang">GitHub</a>找到更多的讨论。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Yeoman创建ASP.NET Core项目]]></title>
        <id>https://songsong.org/post/yeoman-aspnet-core</id>
        <link href="https://songsong.org/post/yeoman-aspnet-core">
        </link>
        <updated>2017-11-08T15:53:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1yeoman-是什么">1.Yeoman 是什么？</h2>
<p>Yeoman是一个自动化脚手架工具。它提供很多generator，generator相当于模板，用来初始化项目。具体的大家可以看 <a href="http://yeoman.io/">http://yeoman.io/</a></p>
<h2 id="2安装-yeoman">2.安装 Yeoman</h2>
<p>安装yeoman之前你需要先安装npm。npm是一个JavaScript的包管理工具，一般跟nodejs配合使用。https://docs.npmjs.com/getting-started/what-is-npm</p>
<p>使用npm来安装 Yeoman：</p>
<pre><code>npm install -g yo
</code></pre>
<h2 id="3安装-generator-aspnet">3.安装 generator-aspnet</h2>
<p>generator-aspnet就是asp.net core的构建器了，我们需要安装它,由于它还依赖bower工具，所以我们要一起安装。</p>
<pre><code>npm install -g bower
npm install -g generator-aspnet
</code></pre>
<h2 id="4使用-yeoman">4.使用 Yeoman</h2>
<p>使用之前我们先假设一下我们的项目叫YeomanDemo,我们先新建一个项目的根目录YeomanDemo</p>
<h3 id="使用yeoman创建yeomandemo">使用Yeoman创建YeomanDemo</h3>
<p>Yeoman会显示一个界面让你去选择创建的项目的类型
<img src="https://songsong.org/post-images/1558972505301.png" alt="">
选中<code>Empty Web Application</code>项目之后回车
<img src="https://songsong.org/post-images/1558972509588.png" alt="">
接着输入项目名称 <code>YeomanDemo</code> 之后项目就创建成功了。</p>
<p>你可以执行以下命令，来运行项目。</p>
<pre><code>dotnet restore
dotnet build
dotnet run
</code></pre>
<h3 id="使用yeoman创建middleware">使用Yeoman创建middleware</h3>
<p>Yeoman功能很强大，还可以安装其他的generator，比如</p>
<pre><code>npm install -g generator-aspnetcore-middleware
</code></pre>
<p>安装完成后，你可以输入</p>
<pre><code>yo aspnetcore-middleware
</code></pre>
<p>输入中间件名称后，就成功创建了Middleware模板。</p>
<h2 id="5总结">5.总结</h2>
<p>使用Yeoman只要几个简单的命令，就帮助我们建立一个项目，感兴趣的可以自己编写一个generator玩玩</p>
]]></content>
    </entry>
</feed>