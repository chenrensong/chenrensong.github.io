<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>【译】在 ASP.NET Core 中使用 SignalR | 陈仁松博客</title>
<link rel="shortcut icon" href="https://songsong.org/favicon.ico?v=1558972821336">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://songsong.org/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://songsong.org">
  <img class="avatar" src="https://songsong.org/images/avatar.png?v=1558972821336" alt="">
  </a>
  <h1 class="site-title">
    陈仁松博客
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/chenrensong" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              【译】在 ASP.NET Core 中使用 SignalR
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2017-10-02 ·
              </time>
              
                <a href="https://songsong.org/tag/dotnet" class="post-tag">
                  # dotnet
                </a>
              
            </div>
            
            <div class="post-content">
              <h2 id="介绍">介绍</h2>
<p><strong>SignalR</strong>是一个用于网站实现实时通信.NET库。可用多种技术来实现服务器与客户端间的双向通信，服务器可以随时将消息推送到连接的客户端。</p>
<p>现在可在 ASP.NET Core 预发行版本中使用。我已经介绍过几次 SignalR 了。</p>
<h2 id="安装">安装</h2>
<p>您将需要安装 Microsoft.AspNetCore.SignalR.Client 和 Microsoft.AspNetCore.SignalR Nuget 预发行包。此外，您将需要 <a href="https://www.npmjs.com/">NPM</a>（Node 包管理器）。安装 NPM 后，您需要获取 <a href="https://www.npmjs.com/package/@aspnet/signalr-client">@aspnet/signalr-client</a> 包，之后您需要从 <strong>node_modules@aspnet\signalr-client\dist\browser</strong> 文件夹中 获取 <strong>signalr-client-1.0.0-alpha1-final.js</strong> 文件（版本可能不同） ，并将其放置在 <strong>wwwroot</strong> 文件夹下，以便您可以从页面引用到它。</p>
<p>接下来，我们需要在使用之前在 <strong>ConfigureServices</strong> 中注册所需的服务：</p>
<pre><code>services.AddSignalR();
</code></pre>
<p>我们将实现一个简单的聊天客户端，因此将在 <strong>Configure</strong> 方法中注册一个 ChatHub：</p>
<pre><code>app.UseSignalR(routes =&gt;
{
    routes.MapHub&lt;ChatHub&gt;(&quot;chat&quot;);
});
</code></pre>
<p>注意：<strong>UseSignalR</strong> 必须在 <strong>UseMvc</strong> 之前调用！</p>
<p>如果你有不同的端点，可以为任意数量的 hub 执行此操作。</p>
<p>在您的视图或布局文件中，添加对 <strong>signalr-client-1.0.0-alpha1-final.js</strong> 文件的引用：</p>
<pre><code>&lt;script src=&quot;libs/signalr-client/signalr-client-1.0.0-alpha1-final.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="实现-hub">实现 Hub</h2>
<p>该 hub 是一个继承了 <strong>Hub</strong> 的类。您可在其中添加 JavaScript 可能调用到的方法。我们将实现一个 chat hub：：</p>
<pre><code>public class ChatHub : Hub
{
    public async Task Send(string message)
    {
        await this.Clients.All.InvokeAsync(&quot;Send&quot;, message);
    }
}
</code></pre>
<p>如你所见，我们有一个方法（<strong>Send</strong>），在这个例子中，它采用单个参数（<strong>message</strong>）。您不需要在广播调用（<strong>InvokeAsync</strong>）上传递相同的参数，可以发送任何您想要的。</p>
<p>回到客户端部分，在引用 SignalR JavaScript 文件后添加此代码：</p>
<pre><code>   &lt;script&gt;

        var transportType = signalR.TransportType.WebSockets;
        //can also be ServerSentEvents or LongPolling
        var logger = new signalR.ConsoleLogger(signalR.LogLevel.Information);
        var chatHub = new signalR.HttpConnection(`http://${document.location.host}/chat`, { transport: transportType, logger: logger });
        var chatConnection = new signalR.HubConnection(chatHub, logger);

        chatConnection.onClosed = e =&gt; {
            console.log('connection closed');
       };

       chatConnection.on('Send', (message) =&gt; {
           console.log('received message');
       });

       chatConnection.start().catch(err =&gt; {
           console.log('connection error');
       });

       function send(message) {
           chatConnection.invoke('Send', message);
       }

&lt;/script&gt;
</code></pre>
<p>请注意：</p>
<ol>
<li>创建指向当前 URL 的连接添加了 <strong>chat</strong> 后缀，这与在 <strong>MapHub</strong> 中注册的一致</li>
<li>它使用特定的传输进行初始化（本例中是 <strong>WebSockets</strong>），但这不是必需的，也就是说，您可以让 SignalR 自己采用合适的方式。对于某些操作系统（如 Windows 7），您可能无法使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>，因此您必须选择 <a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">LongPolling</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events">ServerSentEvents</a></li>
<li>需要通过调用 <strong>start</strong> 来初始化连接</li>
<li>有一个 <strong>Send</strong> 方法的 handler，它与 <strong>ChatHub</strong> 的 <strong>Send</strong> 方法有相同的单个参数（message）</li>
</ol>
<p>所以，每当有人访问此页面并调用 JavaScript <strong>send</strong>函数时，它将调用 <strong>ChatHub</strong> 类上的 <strong>Send</strong> 方法。 该类基本上会向所有连接的客户端（<strong>Clients.All</strong>）广播此消息。 也可以将消息发送到特定的组：</p>
<pre><code>await this.Clients.Group(&quot;groupName&quot;).InvokeAsync(&quot;Send&quot;, message);
</code></pre>
<p>或特定客户端：</p>
<pre><code>await this.Clients.Client(&quot;id&quot;).InvokeAsync(&quot;Send&quot;, message);
</code></pre>
<p>如果使用身份验证，您可以添加一个由连接 ID 和 <strong>ClaimPrincipal</strong> 标识的用户，如下所示：</p>
<pre><code>public override Task OnConnectedAsync()
{
    this.Groups.AddAsync(this.Context.ConnectionId, &quot;groupName&quot;);

    return base.OnConnectedAsync();
}
</code></pre>
<p>是的，<strong>OnConnectedAsync</strong> 在新用户连接时将被调用。当有人断开连接时，<strong>OnDisconnectedAsync</strong> 将被调用：</p>
<pre><code>public override Task OnDisconnectedAsync(Exception exception)
{
    return base.OnDisconnectedAsync(exception);
}
</code></pre>
<p>如果在断开连接时发生一些异常，则 <strong>exception</strong> 参数将为非空值。
只有当前用户进行身份验证时 <strong>Context</strong> 属性才会提供 <strong>ConnectionId</strong> 和 <strong>User</strong> 两个属性。<strong>ConnectionId</strong> 始终被设置为同一个用户，不会改变。
另一个例子，假设你想通过定时器 hub 将定时器 tick 发送到所有连接的客户端。 您可以在 <strong>Configure</strong> 方法中执行此操作：</p>
<pre><code>TimerCallback callback = (x) =&gt; {
    var hub = serviceProvider.GetService&lt;IHubContext&lt;TimerHub&gt;&gt;();
    hub.Clients.All.InvokeAsync(&quot;Notify&quot;, DateTime.Now);
};

var timer = new Timer(callback);
timer.Change(TimeSpan.FromSeconds(0), TimeSpan.FromSeconds(10));
</code></pre>
<p>我们启动了一个 <strong>Timer</strong>，从那里我们得到了一个定时器 hub 的引用，并使用当前时间戳调用其 <strong>Notify</strong> 方法。<strong>TimerHub</strong> 类只是这样：</p>
<pre><code>public class TimerHub : Hub
{
}
</code></pre>
<p>请注意，此类没有公共方法，因为它不是由 JavaScript 调用，它仅用于从外部广播消息（<strong>Timer</strong> 回调）。</p>
<h2 id="将消息发送到-hub">将消息发送到 Hub</h2>
<p>最后，还可以将消息从外部发送到 hub。当使用控制器时，您需要注入一个 <strong>IHubContext</strong> 实例，您可以从中发送消息到 hub，然后将其适当地广播：</p>
<pre><code>private readonly IHubContext&lt;ChatHub&gt; _context;

[HttpGet(&quot;Send/{message}&quot;)]
public IActionResult Send(string message)
{
    //for everyone
    this._context.Clients.All.InvokeAsync(&quot;Send&quot;, message);
    //for a single group
    this._context.Clients.Group(&quot;groupName&quot;).InvokeAsync(&quot;Send&quot;, message);
    //for a single client
    this._context.Clients.Client(&quot;id&quot;).InvokeAsync(&quot;Send&quot;, message);

    return this.Ok();
}
</code></pre>
<p>请注意，这与访问 <strong>ChatHub</strong> 类不同，您无法简单实现，需要通过 chat hub 的连接才行。</p>
<h2 id="结论">结论</h2>
<p>SignalR 尚未发布，仍可能会发生一些变化。在以后的文章中，我将更详细地介绍 SignalR，包括其可扩展性机制和一些更高级的使用场景。敬请期待！</p>
<p><strong>查看英文原文</strong>：<a href="https://weblogs.asp.net/ricardoperes/signalr-in-asp-net-core">SignalR in ASP.NET Core</a></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://songsong.org/post/dotnet-core-standard-difference">
              <h3 class="post-title">
                【译】.NET Core和.NET Standard有什么不同
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '382981c785b131b4a314',
    clientSecret: '048bc4e7cb57301643ef37a9b2a2ab6a08299deb',
    repo: 'chenrensong.github.io',
    owner: 'chenrensong',
    admin: ['chenrensong'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  京ICP备14060483号 | 
  <a class="rss" href="https://songsong.org/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
